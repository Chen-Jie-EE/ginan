
// #pragma GCC optimize ("O0")

#include <boost/log/trivial.hpp>

#include <fstream>
#include <string>
#include <chrono>

using std::chrono::system_clock;
using std::string;

#include "peaCommitStrings.hpp"
#include "instrument.hpp"
#include "navigation.hpp"
#include "constants.hpp"
#include "acsConfig.hpp"
#include "algebra.hpp"
#include "gTime.hpp"
#include "trace.hpp"
#include "erp.hpp"


/** read earth rotation parameters
 */
void readerp(
	string	filename,		///< IGS ERP file (IGS ERP ver.2)
	ERP&	erp)			///< earth rotation parameters
{
	std::ifstream filestream(filename);
	if (!filestream)
	{
//         trace(2,"erp file open error: file=%s\n",file);
		return;
	}
	
	while (filestream)
	{
		string line;
		
		getline(filestream, line);

		double v[14]	= {};
		double mjdval	= 0;
		int found = sscanf(line.c_str(),"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
				&mjdval,v+1,v+2,v+3,v+4,v+5,v+6,v+7,v+8,v+9,v+10,v+11,v+12,v+13);
		if (found < 5)
		{
			continue;
		}
		
		MjDateUtc mjd;
		mjd.val = mjdval;
	
		ERPValues erpv;
		
 		erpv.time	= mjd;
		erpv.xp		= v[1]	* 1E-6*AS2R;
		erpv.yp		= v[2]	* 1E-6*AS2R;
		erpv.ut1Utc	= v[3]	* 1E-7;
		erpv.lod	= v[4]	* 1E-7;
		erpv.xpr	= v[12]	* 1E-6*AS2R;
		erpv.ypr	= v[13]	* 1E-6*AS2R;
		
		erp.erpMap[erpv.time] = erpv;
	}
}


/** Get earth rotation parameter values
 */
ERPValues geterp(
	ERP&			erp,
	GTime			time)
{
	Instrument instrument(__FUNCTION__);
	
	ERPValues erpv;
	
	if (erp.erpMap.empty())
		return erpv;
	
	//find two erps to interpolate between (may be duplicate)
	ERPValues* erp1_ptr;
	ERPValues* erp2_ptr;
	
	auto it = erp.erpMap.lower_bound(time);
	
	if		(it == erp.erpMap.end())
	{
		auto lastIt = erp.erpMap.rbegin();
		
		auto& [dummy, last] = *lastIt;
		erp1_ptr = &last;
		erp2_ptr = &last;
	}
	else if (it == erp.erpMap.begin())
	{
		auto& [dummy, first] = *it;
		erp1_ptr = &first;
		erp2_ptr = &first;
	}
	else
	{
		auto& [dummy2, erp2] = *it;
		erp2_ptr = &erp2;
		it--;
		
		auto& [dummy1, erp1] = *it;
		erp1_ptr = &erp1;
	}
	
	ERPValues& erp1 = *erp1_ptr;
	ERPValues& erp2 = *erp2_ptr;
	
	//interpolate values between erps
	double a;
	if (erp2.time == erp1.time)		a	= 0;	
	else							a	= (time			- erp1.time).to_double()
										/ (erp2.time	- erp1.time).to_double();	
	
	erpv.xp		= (1-a) * erp1.xp		+ a * erp2.xp;
	erpv.yp		= (1-a) * erp1.yp		+ a * erp2.yp;
	erpv.ut1Utc	= (1-a) * erp1.ut1Utc	+ a * erp2.ut1Utc;
	erpv.lod	= (1-a) * erp1.lod		+ a * erp2.lod;
	
	return erpv;
}

void writeERP(
	string		filename,
	ERPValues&	erp)
{
	if (filename.empty())
	{
		return;
	}
	
	std::ofstream erpStream(filename, std::ios::app);

	if (!erpStream)
	{
		BOOST_LOG_TRIVIAL(error) << "Error opening " << filename << " for ERP file.";
		
		return;
	}

	erpStream.seekp(0, erpStream.end);					// seek to end of file

	if (erpStream.tellp() == 0)
	{
		erpStream << "VERSION 2" << std::endl;
		erpStream << " Generated by GINAN " << ginanCommitVersion() << " branch " << ginanBranchName() << std::endl;
		
		erpStream << "----------------------------------------------------------------------------------------------------------------" << std::endl;
		erpStream << "       MJD    Xpole    Ypole  UT1-UTC      LOD     Xsig     Ysig    UTsig   LODsig  Nr  Nf  Nt      Xrt      Yrt" << std::endl;
		erpStream << "             1E-6as   1E-6as    1E-7s  1E-7s/d   1E-6as   1E-6as    1E-7s  1E-7s/d               1E-6/d   1E-6/d" << std::endl;
	} 
	
	int numRecs			= 0;
	int numFixedRecs	= 0;
	int numSats			= 0;
		
	MjDateUtc mjd = erp.time;
	
	tracepdeex(0, erpStream, "%8.4f %8d %8d %8d %8d %8d %8d %8d %8d %3d %3d %3d %8d %8d\n",
					mjd.to_double(),
			(int)	(erp.xp				* 1E6 * R2AS),
			(int)	(erp.yp				* 1E6 * R2AS),
			(int)	(erp.ut1Utc			* 1E7),
			(int)	(erp.lod			* 1E7),
			(int)	(erp.xpSigma		* 1E6 * R2AS),  
			(int)	(erp.ypSigma		* 1E6 * R2AS),
			(int)	(erp.ut1UtcSigma	* 1E7),
			(int)	(erp.lodSigma		* 1E7),
					numRecs,            
					numFixedRecs,       
					numSats,            
			(int)	(erp.xpr			* 1E6 * R2AS),
			(int)	(erp.ypr			* 1E6 * R2AS));
}

void writeERPFromNetwork(
	string		filename,
	KFState&	kfState)
{
	static GTime lastTime = GTime::noTime();
	
	if (abs((lastTime - kfState.time).to_double()) < 10)
	{
		//dont write duplicate lines (closer than 10s (4dp mjd))
		return;
	}
	
	lastTime = kfState.time;

	ERPValues erpv;
	erpv.time = kfState.time;
	
	bool found = false;
	
	KFKey kfKey;
	
	kfKey.type = KF::EOP;
	kfKey.num = 0;		found |= kfState.getKFValue(kfKey,	erpv.xp,		&erpv.xpSigma		);			erpv.xp		*= MAS2R;		erpv.xpSigma		= sqrt(erpv.xpSigma)		* MAS2R;
	kfKey.num = 1;		found |= kfState.getKFValue(kfKey,	erpv.yp,		&erpv.ypSigma		);			erpv.yp		*= MAS2R;		erpv.ypSigma		= sqrt(erpv.ypSigma)		* MAS2R; 
	kfKey.num = 2;		found |= kfState.getKFValue(kfKey,	erpv.ut1Utc,	&erpv.ut1UtcSigma	);			erpv.ut1Utc	*= MTS2S;		erpv.ut1UtcSigma	= sqrt(erpv.ut1UtcSigma)	* MTS2S; 
	
	kfKey.type = KF::EOP_RATE;
	kfKey.num = 0;		found |= kfState.getKFValue(kfKey,	erpv.xpr,		&erpv.xprSigma		);			erpv.xpr	*= MAS2R;		erpv.xprSigma		= sqrt(erpv.xprSigma)		* MAS2R; 
	kfKey.num = 1;		found |= kfState.getKFValue(kfKey,	erpv.ypr,		&erpv.yprSigma		);			erpv.ypr	*= MAS2R;		erpv.yprSigma		= sqrt(erpv.yprSigma)		* MAS2R; 
	kfKey.num = 2;		found |= kfState.getKFValue(kfKey,	erpv.lod,		&erpv.lodSigma		);			erpv.lod	*= MTS2S * -1;	erpv.lodSigma		= sqrt(erpv.lodSigma)		* MTS2S; //lod is negative for some reason
	
	if (found)
	{
		//using old method, enter and return
		
		writeERP(filename, erpv);
		
		return;
	}
	
	ERPValues erpvs[2];
	erpvs[0] = geterp(nav.erp, kfState.time);
	erpvs[1] = geterp(nav.erp, kfState.time + 1);
	
	erpv		= erpvs[0];
	erpv.time	= kfState.time;
	erpv.xpr	= erpvs[1].xp - erpvs[0].xp;	// per 1 second dt
	erpv.ypr	= erpvs[1].yp - erpvs[0].yp;	// per 1 second dt
	
	for (int i = 0; i < 3; i++)
	{
		double adjust			= 0;
		double adjustVar		= 0;
		double rateAdjust		= 0;
		double rateAdjustVar	= 0;
		
		KFKey kfKey;
		kfKey.num	= i;
		
		kfKey.type	= KF::EOP_ADJUST;
		kfState.getKFValue(kfKey, adjust,		&adjustVar);
		
		kfKey.type	= KF::EOP_RATE_ADJUST;
		kfState.getKFValue(kfKey, rateAdjust,	&rateAdjustVar);
		
		switch (i)
		{
			case 0:	erpv.xp		+= adjust		* MAS2R;		erpv.xpSigma		= sqrt(adjustVar)		* MAS2R;
					erpv.xpr	+= rateAdjust	* MAS2R;		erpv.xprSigma		= sqrt(rateAdjustVar)	* MAS2R;	break;
			case 1:	erpv.yp		+= adjust		* MAS2R;		erpv.ypSigma		= sqrt(adjustVar)		* MAS2R;
					erpv.ypr	+= rateAdjust	* MAS2R;		erpv.yprSigma		= sqrt(rateAdjustVar)	* MAS2R;	break;
			case 2:	erpv.ut1Utc	+= adjust		* MTS2S;		erpv.ut1UtcSigma	= sqrt(adjustVar)		* MTS2S;
					erpv.lod	+= rateAdjust	* MTS2S * -1;	erpv.lodSigma		= sqrt(rateAdjustVar)	* MTS2S;	break;	//lod is negative for some reason
			default:
				break;
		}
	}
		
	writeERP(filename, erpv);
}
